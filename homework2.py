from collections import defaultdict, deque

# Graph including all the cities and their path values
graph = {
    'Oradea': {'Zerind': 71, 'Sibiu': 151},
    'Zerind': {'Oradea': 71, 'Arad': 75},
    'Arad': {'Zerind': 75, 'Sibiu': 140, 'Timisoara': 118},
    'Timisoara': {'Arad': 118, 'Lugoj': 111},
    'Lugoj': {'Timisoara': 111, 'Mehadia': 70},
    'Mehadia': {'Lugoj': 70, 'Drobeta': 75},
    'Drobeta': {'Mehadia': 75, 'Craiova': 120},
    'Sibiu': {'Oradea': 151, 'Arad': 140, 'Fagaras': 99, 'Rimnicu Vilcea': 80},
    'Fagaras': {'Sibiu': 99, 'Bucharest': 211},
    'Rimnicu Vilcea': {'Sibiu': 80, 'Pitesti': 97, 'Craiova': 146},
    'Pitesti': {'Rimnicu Vilcea': 97, 'Craiova': 138, 'Bucharest': 101},
    'Craiova': {'Drobeta': 120, 'Rimnicu Vilcea': 146, 'Pitesti': 138},
    'Bucharest': {'Fagaras': 211, 'Pitesti': 101, 'Urziceni': 85, 'Giurgiu': 90},
    'Urziceni': {'Bucharest': 85, 'Vaslui': 142, 'Hirsova': 98},
    'Giurgiu': {'Bucharest': 90},
    'Hirsova': {'Urziceni': 98, 'Eforie': 86},
    'Eforie': {'Hirsova': 86},
    'Vaslui': {'Urziceni': 142, 'Iasi': 92},
    'Iasi': {'Vaslui': 92, 'Neamt': 87},
    'Neamt': {'Iasi': 87}
}

# BFS
def bfs(graph, start, end):
    visited = set()
    queue = deque([(start, [start], 0)])  # Add the cost element (initialized to 0)

    while queue:
        current_city, path, cost = queue.popleft()
        visited.add(current_city)

        if current_city == end:
            return path, cost  # Return both the path and the total cost

        for neighbor, neighbor_cost in graph[current_city].items():
            if neighbor not in visited:
                new_path = path + [neighbor]
                new_cost = cost + neighbor_cost
                queue.append((neighbor, new_path, new_cost))

    return None, float('inf')  # No path found, return an infinite cost

# DFS
def dfs(graph, current_city, goal_city, visited=None, path=None):
    if visited is None:
        visited = set()
    if path is None:
        path = []

    visited.add(current_city)
    path = path + [current_city]

    if current_city == goal_city:
        # Calculate path cost
        path_cost = sum(graph[path[i]][path[i + 1]] for i in range(len(path) - 1))
        return path, path_cost

    for neighbor, _ in sorted(graph[current_city].items(), key=lambda x: x[1]):
        if neighbor not in visited:
            new_path, path_cost = dfs(graph, neighbor, goal_city, visited, path)
            if new_path:
                return new_path, path_cost

    return [], 0  # No path, cost is 0

# A* Search


# Printing the paths for each of the start cities to Bucharest
goal_city = 'Bucharest'

# Test One - from Timisoara
start_city1 = 'Timisoara'
goal_city_dfs = 'Bucharest'
path_dfs, cost_dfs = dfs(graph, start_city1, goal_city)
path_bfs, cost_bfs = bfs(graph, start_city1, goal_city)
print(f"DFS Path from {start_city1} to {goal_city}: {path_dfs}, Cost: {cost_dfs}")
print(f"BFS Path from {start_city1} to {goal_city}: {path_bfs}, Cost: {cost_bfs}")

# Test Two - from Oradea
start_city2 = 'Oradea'
path_dfs, cost_dfs = dfs(graph, start_city2, goal_city)
path_bfs, cost_bfs = bfs(graph, start_city2, goal_city)
print(f"DFS Path from {start_city2} to {goal_city}: {path_dfs}, Cost: {cost_dfs}")
print(f"BFS Path from {start_city2} to {goal_city}: {path_bfs}, Cost: {cost_bfs}")

# Test Three - from Neamt
start_city3 = 'Neamt'
path_dfs, cost_dfs = dfs(graph, start_city3, goal_city)
path_bfs, cost_bfs = bfs(graph, start_city3, goal_city)
print(f"DFS Path from {start_city3} to {goal_city}: {path_dfs}, Cost: {cost_dfs}")
print(f"BFS Path from {start_city3} to {goal_city}: {path_bfs}, Cost: {cost_bfs}")


# -- Paths generated by each algorithm (testing) --

### DFS Paths 
# DFS Path from Timisoara to Bucharest: ['Timisoara', 'Lugoj', 'Mehadia', 'Drobeta', 'Craiova', 'Pitesti', 'Rimnicu Vilcea', 'Sibiu', 'Fagaras', 'Bucharest']
# DFS Path from Oradea to Bucharest: ['Oradea', 'Zerind', 'Arad', 'Timisoara', 'Lugoj', 'Mehadia', 'Drobeta', 'Craiova', 'Pitesti', 'Rimnicu Vilcea', 'Sibiu', 'Fagaras', 'Bucharest']
# DFS Path from Neamt to Bucharest: ['Neamt', 'Iasi', 'Vaslui', 'Urziceni', 'Bucharest']

### BFS Paths
# BFS Path from Timisoara to Bucharest: ['Timisoara', 'Arad', 'Sibiu', 'Fagaras', 'Bucharest'], Cost: 568
# BFS Path from Oradea to Bucharest: ['Oradea', 'Sibiu', 'Fagaras', 'Bucharest'], Cost: 461
# BFS Path from Neamt to Bucharest: ['Neamt', 'Iasi', 'Vaslui', 'Urziceni', 'Bucharest'], Cost: 406


# -- Correctness Discussion for each algorithm --
### DFS
# For DFS the algorithm does work correctly and will actively return an empty list if no such path exists between the start and end goal city however for the longer paths with more options it is not as effective. 
# It does find the shortest path for Neamt especially because there are not too many options for what path the algorithm could look into taking. 
# It found the shortest path when going from Timisoara to Bucharest. 
# It did not find the least costy/shortest path when going from Oreda to Bucharest. It shows the smallest value for each pair of values but overall led it to still being a longer path. 

### BFS


# -- Efficiency Discussion for each algorithm --
### DFS
# The alogorithm is more efficent for when there are fewer options or paths to take and gets less accuracte and efficent the more options you give it. 
# For the path from Oreda to Bucharest it chose the more costly path because the options presented to it were technically shorter but it had to go through more cities to get to Bucharest. 

### BFS
